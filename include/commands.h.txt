/*
 * - заголовок    | SOH | DAD | SAD | ISI | FNC | DataHead |
 *  или безадресный заголовок | SOH | ISI | FNC | DataHead |
 *  - данные                                               | STX | DataSet | ETX |
 *  - контрольная информация                                                     | CRC1 | CRC2 |
 *
 *  DAD  байт адреса приёмника,
 *  SAD  байт адреса источника,
 *  FNC  байт кода функции,
 *  CRC1, CRC2  циклические контрольные коды
 * 
 *  Пример
 *  modbus -> 01 10 00 02 00 0A 14 01 00 86 1F 1D 33 33 32 02 09 30 30 30 09 30 30 33 0C 03 00 59 2D
 *  sp     -> 10 01 00 86 10 1F 1D 33 33 32 10 02 09 30 30 30 09 30 30 33 0C 10 03 42 16
 *  reply  <- FF FF 10 01 86 00 10 1F 03 33 33 32 10 02 09 30 09 30 30 33 0C 09 32 30 36 30 31 30 30 30 30 35 09 20 0C 10 03 32 61

      [0x10, 0x01, 0x00, 0x86, 0x10, 0x1F, 0x1D, 0x33, 0x33, 0x32, 0x10, 0x02, 0x09, 0x30, 0x30, 0x30, 0x09, 0x30, 0x30, 0x33, 0x0C, 0x10, 0x03, 0x42, 0x16]
 */


#pragma once


/* Для структурирования сообщений используются управляющие символы */
#define DLE 0x10    // символ-префикс
#define SOH 0x01    // начало заголовка
#define ISI 0x1F    // указатель кода функции FNC
#define STX 0x02    // начало тела сообщения
#define ETX 0x03    // конец тела сообщения

#define HT  0x09    // разделитель (табуляция)   
#define MF  0x0C    // разделитель (подача формы) 

        // тестовые:
        #define DAD 0x00    // байт адреса приёмника
        #define SAD 0x86    // байт адреса источника 
        #define FNC 0x1D    // байт кода функции


/** Использованы следующие обозначения:
* DAD  байт адреса приёмника,
* SAD  байт адреса источника,
* FNC  байт кода функции,
* CRC1, CRC2  циклические контрольные коды
* 
* Адреса DAD и SAD являются адресами абонентов на магистрали или дополнительном интерфейсе.
* При передаче сообщения через магистраль в адресную часть маркера захвата помещаются 
* пять младших битов из DAD, а в адресную часть маркера подтверждения - из SAD.
* Допускается использование безадресных заголовков вида:
*                           SOH     IS1     FNC     DataHead (так в документе)
*                           SOH     ISI     FNC     DataHead (так в документе)
* Код FNC (байт кода функции) в заголовке сообщения определяет, как должны интерпретироваться
* и обрабатываться данные DataSet из тела сообщения. Если данные отсутствуют, то сообщение 
* является управляющим или подтверждающим выполнение абонентом каких-либо действий.
*/

#include <stdint.h>

/** ---------------------------------------------------------------------------------
 *  Пакет modbus:                                  запрос                               лишний    CRC
 *  01 10 00 02 00 0A 14  |  01 00 86 1F 1D 33 33 32 02 09 30 30 30 09 30 30 33 0C 03  |  00  |  59 2D
 *  Пакет целевому прибору со стаффингом:
 *  10 01 00 86 10 1F 1D 33 33 32 10 02 09 30 30 30 09 30 30 33 0C 10 03 42 16
 *  Ожидаемый ответ (как есть, с FFh FFh - уточнить), включая стаффинг:                    |> 9: 115200
 *       |                       332                     003         |            2060100009          |           | CRC
 *  FF FF 10 01 86 00 10 1F 03 33 33 32 10 02 09 30 09 30 30 33 0C 09 32 30 36 30 31 30 30 30 30 35 09 20 0C 10 03 32 61
 * 
 * 
 * 
 *  -------------------------------------------------------------------------------*/

/* #define CONFIG_COMMAND_332 (0x01, 0x00, 0x86, 0x1F, 0x1D, 0x33, 0x33, 0x32, 0x02, \
                 0x09, 0x30, 0x30, 0x30, 0x09, 0x30, 0x30, 0x33, 0x0C, 0x03)
*/
//#define CONFIG_COMMAND_332 (SOH, DAD, SAD, ISI, FNC, `3`, `3`, `2`, STX, HT, `0`, `0`, `0`, HT, `0`, `0`, `3`, FF, ETX)

// Байтовый массив команды с явным указанием размера
const uint8_t command_332[] = { SOH, DAD, SAD, 
                                         ISI, FNC, 3, 3, 2, STX, HT,
                                         0, 0, 0, HT, 0, 0, 
                                         3, MF, ETX



    //     0x01, 0x00, 0x86, 0x1F, 
    //     0x1D, 0x33, 0x33, 0x32, 
    //     0x02
};


3.5 Чтение параметров
В заголовке запроса указывается FNC=1Dh. Поле DataHead может содержать произвольную информацию длиной до 80 байтов без учета возможных стаффинг символов DLE.
Поле DataSet содержит указатели запрашиваемых параметров, ограниченные разделителем FF, то
есть имеет вид:
Указатель 1 FF Указатель 2 FF .... Указатель N FF
Все указатели имеют одинаковый формат:
HT Номер канала HT Номер параметра
Номера каналов и параметров задаются целыми числами в символьном формате.
В заголовке ответа указывается FNC=03h. Поле DataHead содержит ту же информацию, которая
содержалась в заголовке запроса. Таким образом, в поле можно располагать информацию для идентификации приложения, 
из которого направляются запросы к абоненту.
Поле DataSet в ответе состоит из N последовательных блоков одинаковой структуры:
Указатель i FF Информация i FF
Поле "Информация" в свою очередь распадается на поля:

HT Значение HT Единицы HT Метка времени
В поле "Значение" в символьном формате лицевой панели прибора представлено значение параметра, 
заданного соответствующим указателем. 
Поля "Единицы" и "Метка времени" также относятся
к указанному параметру.
Какое-либо из полей может отсутствовать. Однако в этом случае остается его начальный разделитель НТ. 
Это позволяет правильно интерпретировать содержимое всех полей.
Если в блоке "Информация" отсутствуют подряд несколько последних полей, то их можно опустить
вместе с разделителями, т.к. блок ограничен разделителем FF. Это позволяет правильно 
интерпретировать поля в следующем блоке. 
Например, при отсутствии единиц и метки времени сразу за полем
значения может следовать FF. Подчеркнем, что отсутствие поля единиц не означает, что параметр не
имеет размерности. Для безразмерных параметров указывается "б/р".
Если по каким-либо причинам значение параметра не может быть определено, тогда в поле "Значение" помещается краткий 
диагностический текст, уточняющий причину отказа. В этом случае последующие поля этого параметра отсутствуют.



/*
* Тестовый пакет (modbus RTU) (961 СП4: 2060100009):
* 01 10 00 00 00 0A 14  01 00  86 1F  1D 33  33 32  02 09  30 30  30 09  30 30  33 0C  03 00  E0 47 
*                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  |< лишний байт, т.к. регистры двухбайтовые
* Принятый пакет (modbus RTU): 
  01 10 00 1F 01 86 00 1F 03 33 33 32 02 09 30 09 30 30 33 0C 09 32 30 36 30 31 30 30 30 30 39 09 20 0C 03 00 6F //2060100009 
* 01 10 00 1F 01 86 00 1F 03 33 33 32 02 09 30 09 30 30 33 0C 09 32 30 36 30 31 30 30 30 30 35 09 20 0C 03 00 7F //2060100005
*             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^!!^^^^^^^^^^^^
*                         Ком 3  3  2 Нач Гт 0 Гт 0  0  3 Стр Гт  2  0  6  0  1  0  0  0  0 9/5 Гт  Стр Кон       115200/9600 
*               байтов:31       332          0      003           <---- СП4 = 2060100009 ---->  OK
* Выделены байты, отправляемые и получаемые при тестировании целевого прибора
* Тестовый пакет сгенерирован приложением DataBase2.
*/


// ================================== Чтение элементов индексного массива ==================================
Настройки COM-порта COM 6, 9600, None, 8, 1
Настройки СПТ961.2  СП4: 2060100009

Запрос - случайным образом выбранный запрос (hex): 
01 00 80 1F                 - Заголовок
0C                          - Команда читать элемент индексного массива
32                          - какой-то непонятный код `2`
02                          - код начала данных 
09 30 09 35 09 30 09 36     - указатель, задающий номер канала, номер массива, начало и количество
0С                          - разделитель
03                          - конец запроса

1. Адрес Slave ID (hex)  1
2. Адрес (hex)  40
3. Количество регистров не более 48
4. 0x03 Чтение регистров хранения 
5. 0x10 Запись нескольких регистров
6. Добавить регистр
7. Ввести первые два байта запроса 0С32, начиная с кода команды FNC, байты SOH, DAD, SAD, ISI введутся автоматически
8. Добавляя регистр вводить следующие два байта: 0209, 3009 и т.д.
9. При вводе нечётного количества байтов отсутствующий байт задать нулём: 0300
10. Подключить, выбрать "Историю обмена".
11. Записать.
12. Проверить ввод: 01  10  00  40  00  07  0E     `0C  32  02  09  30  09  35  09  30  09  36  0C  03  00`    AB  50 
    (данные будут упакованы в модбас-пакета)
    и ответ терминалу: 01  10  00  40  00  07  80  1F (команда 10, адрес 0040, 0007 регистров)
    в итоге подготовлен файл запроса.
    Можно проверить ввод, прочитав регистры хранения (п.2 и п.3)

Запись файла запроса в память нашего устройства под идентификационным номером ID (всего до 42 файлов):
1. Адрес (hex)  0F (0x0F - запись ID в этот регистр инициирует запись файла запроса в долговременную память прибора)
2. 0x06 Запись одного регистра 
3. Ввести идентификационный номер для введённого файла (hex) из из диапазона 0000 до 0029, например 0020
4. Записать, дождаться сброса регистра команды 0x0F в 0xFFFF
5. Подтверждение 01  06  00  0F  00  20  B8  11 : 06 - запись в регистр 000F 0020 (ID файла)
6. Файл запроса можно вывести в регистры и прочитать, записав ID в регистр 0x0E и прочитав по команде 0x03 до 48 
   регистров. Считанный таким образом в регистры файл будет начинаться дополнительным байтом длины файла:
     01  03  60    `0D`  0C  32  02  09  30  09  35  09  30  09  36  0C  03  
  где  `0D` - длина файла 13 байтов.
  Примечание: Заголовок запроса попрежнему отсутствует, так как он содержит адреса устройств, которые на момент 
  использования могут быть уже иными, нежели при вводе в долговременную память прибора.
  Интересно: если при чтении вместо 48 запросить 96 регистров, то можно обнаружить в считанном массиве не только 
  записанный, но и первоначально введённый массив данных. Это свойство двойного по размеру количества регистров 
  используется для вывода увеличенного вдвое объёма после парсинга ответа.

  Как это использовать.
  1. Запишите в регистр 0x0B ID файла запроса
  2. Прочитайте N регистров, начиная с регистра 0x10:
  01   03   70   
  01   80   00   1F   14   
  32   
  02   09   30   09   35   09   30   09   36   
  0C   09   3C   43   52   3E   3C   4C   46   3E   09   20   
  0C   09   8D   A5   E2   20   A4   A0   AD   AD   EB   E5   3F   
  0C   09   41   54   3C   43   52   3E   3C   4C   46   3E   09   20   
  0C   09   4F   4B   3C   43   52   3E   3C   4C   46   3E   09   20   
  0C   09   41   54   2A   45   32   49   50   41   3D   31   2C   31   3C   43   52   3E   3C   4C   46   3E   09   20   
  0C   09   4F   4B   3C   43   52   3E   3C   4C   46   3E   09   20   
  0C   03   

  В данном случае парсинга не происходит, в модбас-регистрах отображается принятый "как есть" пакет от целевого прибора.

  Получение распарсеного пакета на терминал.





Лог:

I (91133) REIA_PARSER: Parameter data (100 bytes):
I (91143) REIA_PARSER: 09 30 09 35 09 30 09 36 0c 09 3c 43 52 3e 3c 4c
I (91143) REIA_PARSER: 46 3e 09 20 0c 09 8d a5 e2 20 a4 a0 ad ad eb e5
I (91153) REIA_PARSER: 3f 0c 09 41 54 3c 43 52 3e 3c 4c 46 3e 09 20 0c
I (91163) REIA_PARSER: 09 4f 4b 3c 43 52 3e 3c 4c 46 3e 09 20 0c 09 41
I (91163) REIA_PARSER: 54 2a 45 32 49 50 41 3d 31 2c 31 3c 43 52 3e 3c
I (91173) REIA_PARSER: 4c 46 3e 09 20 0c 09 4f 4b 3c 43 52 3e 3c 4c 46
I (91183) REIA_PARSER: 3e 09 20 0c
I (91183) REIA_PARSER: Found parameter fields: 6

Field 1:
  Value: <CR><LF>
  Units:

Field 2:
  Value: \x8D\xA5\xE2 \xA4\xA0\xAD\xAD\xEB\xE5?

Field 3:
  Value: AT<CR><LF>
  Units:

Field 4:
  Value: OK<CR><LF>
  Units:

Field 5:
  Value: AT*E2IPA=1,1<CR><LF>
  Units:

Field 6:
  Value: OK<CR><LF>
  Units:
I (91213) REIA_PARSER: Data written to MODBUS registers [16-57]
Successfully parsed! Written 6 parameter fields

Вывод: Нечто похожее на параметр обнаруживается в Field 5:  Value: AT*E2IPA=1,1<CR><LF>  Units:

